"""
Vulnerability Prediction Integration Module

This module integrates ML-based vulnerability prediction with the enhanced scanning system.
"""

import logging
import os
from typing import Dict, List, Any, Optional
from datetime import datetime, timedelta

# Import existing predictor
from ..ml.remediation.nvd_vulnerability_predictor import predict_vulnerabilities
from ..ml.remediation.predictive_vulnerabilities import get_predictive_analysis

logger = logging.getLogger("finguardai.vulnerability_predictor")

class VulnerabilityPredictionIntegrator:
    
    def __init__(self, model_path: Optional[str] = None, env: str = "prod"):
        """
        Initialize the vulnerability predictor
        
        Args:
            model_path: Path to the trained ML model (if None, will use default path)
            env: Environment (dev, test, prod)
        """
        self.env = env
        self.config = self._load_environment_config(env)
        self.model_path = model_path or self._get_default_model_path()
        self.logger = logger
        
    def predict_future_vulnerabilities(self, scan_results: Dict[str, Any]) -> Dict[str, Any]:
        """
        Predict potential future vulnerabilities based on scan results
        
        Args:
            scan_results: Results from vulnerability scanning
            
        Returns:
            Dictionary with vulnerability predictions and reasoning
        """
        logger.info("Predicting future vulnerabilities based on scan results")
        
        try:
            # Get predictions from the NVD predictor
            predictions = predict_vulnerabilities(scan_results)
            
            # Add additional context from the predictive analysis
            enhanced_predictions = self._enhance_predictions(predictions, scan_results)
            
            # Filter out any predictions without proper reasoning
            valid_predictions = [p for p in enhanced_predictions if self._validate_prediction(p)]
            
            # Sort by confidence (highest first)
            sorted_predictions = sorted(
                valid_predictions, 
                key=lambda x: x.get("confidence", 0), 
                reverse=True
            )
            
            return {
                "predictions": sorted_predictions,
                "prediction_summary": self._generate_summary(sorted_predictions),
                "prediction_date": datetime.now().isoformat()
            }
            
        except Exception as e:
            logger.error(f"Error predicting vulnerabilities: {str(e)}")
            return {
                "predictions": [],
                "prediction_summary": "Error generating predictions",
                "error": str(e)
            }
    
    def _load_environment_config(self, env: str) -> Dict[str, Any]:
        """
        Load environment-specific configuration
        
        Args:
            env: Environment (dev, test, prod)
            
        Returns:
            Dictionary containing environment-specific configuration
        """
        # Define default configurations for different environments
        default_configs = {
            "dev": {
                "prediction_threshold": 0.3,  # Lower threshold for development to catch more potential issues
                "max_predictions": 10,
                "include_low_confidence": True,
                "use_mock_data": False  # Never use mock data, ensure we process real scan results
            },
            "test": {
                "prediction_threshold": 0.5,
                "max_predictions": 15,
                "include_low_confidence": True,
                "use_mock_data": False
            },
            "prod": {
                "prediction_threshold": 0.6,  # Higher threshold for production to reduce false positives
                "max_predictions": 20,
                "include_low_confidence": False,
                "use_mock_data": False
            }
        }
        
        # Use prod settings as fallback
        return default_configs.get(env, default_configs["prod"])
    
    def _get_default_model_path(self) -> str:
        """
        Get the default path to the ML model
        
        Returns:
            Path to the default ML model
        """
        # Determine the base directory
        base_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
        # Path to models directory
        models_dir = os.path.join(base_dir, "ml", "models")
        # Ensure the directory exists
        os.makedirs(models_dir, exist_ok=True)
        # Default model path
        return os.path.join(models_dir, "vulnerability_predictor_model.pkl")
    
    def _enhance_predictions(self, predictions: List[Dict[str, Any]], scan_results: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Add additional context and reasoning to predictions"""
        enhanced_predictions = []
        
        for pred in predictions:
            # Ensure prediction has all required fields
            if "name" not in pred or not pred["name"]:
                continue
                
            enhanced_pred = pred.copy()
            
            # Add confidence if missing
            if "confidence" not in enhanced_pred:
                enhanced_pred["confidence"] = self._calculate_confidence(pred)
                
            # Add reasoning if missing
            if "reasoning" not in enhanced_pred or not enhanced_pred["reasoning"]:
                enhanced_pred["reasoning"] = self._generate_reasoning(pred, scan_results)
                
            # Add timeframe if missing
            if "timeframe" not in enhanced_pred:
                enhanced_pred["timeframe"] = self._estimate_timeframe(pred)
                
            # Add remediation_steps if missing
            if "remediation_steps" not in enhanced_pred:
                enhanced_pred["remediation_steps"] = self._generate_remediation(pred)
                
            enhanced_predictions.append(enhanced_pred)
            
        return enhanced_predictions
    
    def _validate_prediction(self, prediction: Dict[str, Any]) -> bool:
        """Check if a prediction has all required fields and valid data"""
        required_fields = ["name", "description", "confidence", "reasoning"]
        
        # Check required fields
        for field in required_fields:
            if field not in prediction or not prediction[field]:
                return False
                
        # Validate confidence is a number between 0 and 1
        try:
            confidence = float(prediction["confidence"])
            if confidence < 0 or confidence > 1:
                return False
        except (ValueError, TypeError):
            return False
            
        return True
    
    def _calculate_confidence(self, prediction: Dict[str, Any]) -> float:
        """Calculate confidence score for a prediction"""
        # Default confidence
        return 0.7
    
    def _generate_reasoning(self, prediction: Dict[str, Any], scan_results: Dict[str, Any]) -> str:
        """Generate reasoning for a prediction based on scan data"""
        vuln_name = prediction.get("name", "").lower()
        
        # Generic reasoning based on vulnerability type
        if "sql" in vuln_name:
            return "Based on database technologies detected and similar patterns in existing vulnerabilities"
        elif "xss" in vuln_name or "cross-site" in vuln_name:
            return "Web application technologies detected often develop XSS vulnerabilities in future releases"
        elif "rce" in vuln_name or "execution" in vuln_name:
            return "System has services that historically develop remote code execution vulnerabilities"
        elif "ssl" in vuln_name or "tls" in vuln_name:
            return "Based on SSL/TLS configuration and known vulnerability patterns in similar systems"
        else:
            return "Based on vulnerability trends and technology configurations in the scanned system"
    
    def _estimate_timeframe(self, prediction: Dict[str, Any]) -> str:
        """Estimate timeframe for a prediction"""
        confidence = prediction.get("confidence", 0)
        
        if confidence >= 0.8:
            return "1 to 3 months"
        elif confidence >= 0.6:
            return "3 to 6 months"
        else:
            return "6 to 12 months"
    
    def _generate_remediation(self, prediction: Dict[str, Any]) -> List[str]:
        """Generate remediation steps for a prediction"""
        vuln_name = prediction.get("name", "").lower()
        
        # Generic remediation steps based on vulnerability type
        if "sql" in vuln_name:
            return [
                "Implement parameterized queries",
                "Apply least privilege database access",
                "Use input validation and sanitization",
                "Monitor for new database-related CVEs"
            ]
        elif "xss" in vuln_name or "cross-site" in vuln_name:
            return [
                "Implement Content Security Policy",
                "Use proper output encoding",
                "Validate all user inputs",
                "Monitor for new web framework CVEs"
            ]
        elif "rce" in vuln_name or "execution" in vuln_name:
            return [
                "Apply security patches promptly",
                "Implement strict input validation",
                "Use container isolation where possible",
                "Regularly audit code for injection vulnerabilities"
            ]
        elif "ssl" in vuln_name or "tls" in vuln_name:
            return [
                "Regularly audit TLS configurations",
                "Disable outdated protocols and cipher suites",
                "Implement certificate monitoring",
                "Follow TLS best practices"
            ]
        else:
            return [
                "Monitor security bulletins for related technologies",
                "Apply security patches promptly",
                "Conduct regular security testing",
                "Implement defense in depth"
            ]
    
    def _generate_summary(self, predictions: List[Dict[str, Any]]) -> str:
        """Generate a summary of the predictions"""
        if not predictions:
            return "No future vulnerabilities predicted at this time"
            
        high_confidence = sum(1 for p in predictions if p.get("confidence", 0) >= 0.7)
        total = len(predictions)
        
        if high_confidence > 0:
            return f"Predicted {total} potential future vulnerabilities with {high_confidence} high confidence predictions"
        else:
            return f"Predicted {total} potential future vulnerabilities with low to medium confidence"

# Helper function for easy access
def get_vulnerability_predictions(scan_results: Dict[str, Any], env: str = "prod") -> Dict[str, Any]:
    """
    Get vulnerability predictions based on scan results
    
    Args:
        scan_results: Vulnerability scan results
        
    Returns:
        Dictionary with predictions
    """
    predictor = VulnerabilityPredictionIntegrator(env=env)
    return predictor.predict_future_vulnerabilities(scan_results)
