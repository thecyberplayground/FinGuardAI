"""
Comprehensive Vulnerability Scanner

This module provides advanced vulnerability scanning capabilities using nmap
and other specialized tools to identify a wide range of security issues.
"""

import os
import re
import json
import time
import logging
import subprocess
import xml.etree.ElementTree as ET
from typing import Dict, List, Any, Optional, Set, Tuple
from datetime import datetime

# Import specialized modules
try:
    # Try relative imports first (when imported as part of the package)
    from .port_range_helper import port_in_range
    from .db_security_analyzer import analyze_database_security
    from .web_security_analyzer import analyze_web_security
    from .financial_impact_analyzer import calculate_financial_impact
    from .config import logger
except ImportError:
    # Fall back to absolute imports (when imported directly)
    from integrated_system.port_range_helper import port_in_range
    from integrated_system.db_security_analyzer import analyze_database_security
    from integrated_system.web_security_analyzer import analyze_web_security
    from integrated_system.financial_impact_analyzer import calculate_financial_impact
    from integrated_system.config import logger

class VulnerabilityScanner:
    """
    Comprehensive vulnerability scanner using nmap and specialized techniques
    to identify a wide range of security issues beyond just technology detection.
    """
    
    def __init__(self, output_dir: Optional[str] = None):
        """
        Initialize the vulnerability scanner
        
        Args:
            output_dir: Directory to store scan results
        """
        self.output_dir = output_dir or os.path.join(
            os.path.dirname(os.path.dirname(os.path.abspath(__file__))), 
            "scan_results"
        )
        os.makedirs(self.output_dir, exist_ok=True)
        self.logger = logging.getLogger("finguardai.vulnerability_scanner")
    
    def scan_target(self, target: str, ports: str = "1-1000", intensity: str = "normal") -> Dict[str, Any]:
        """
        Perform a comprehensive vulnerability scan on the target
        
        Args:
            target: Target to scan (IP, hostname, or URL)
            ports: Port specification (e.g., "21-25,80,443,3306,8080-8090")
            intensity: Scan intensity (normal, aggressive, or stealthy)
            
        Returns:
            Dictionary with scan results
        """
        self.logger.info(f"Starting vulnerability scan of {target} (intensity: {intensity})")
        
        # Ensure standard database and web server ports are included
        port_list = set(ports.split(","))
        
        # Add common database ports if not already specified
        common_ports = {
            # Web server ports
            "80", "443", "8080", "8443",
            # Database ports - MySQL, PostgreSQL, MSSQL, Oracle, MongoDB, Redis, Cassandra
            "3306", "5432", "1433", "1521", "27017", "6379", "9042",
            # Financial services ports
            "8843", "9443"
        }
        
        # Add common ports if not specifically excluded
        for port in common_ports:
            if port not in port_list and not any(port_in_range(port, p) for p in port_list):
                port_list.add(port)
        
        # Convert back to string
        enhanced_ports = ",".join(port_list)
        
        # Timestamp for output files
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        scan_id = f"{target.replace('.', '_')}_{timestamp}"
        
        # Define output files
        xml_output = os.path.join(self.output_dir, f"{scan_id}_vulns.xml")
        
        # Build nmap command based on intensity
        nmap_args = self._build_nmap_args(target, enhanced_ports, intensity, xml_output)
        
        # Run the scan
        try:
            self.logger.info(f"Running nmap with args: {' '.join(nmap_args)}")
            result = subprocess.run(nmap_args, capture_output=True, text=True, check=True)
            
            # Parse XML output
            scan_results = self._parse_nmap_output(xml_output)
            scan_results["scan_id"] = scan_id
            scan_results["target"] = target
            scan_results["scan_time"] = datetime.now().isoformat()
            
            # Add database configuration analysis
            if any(p in scan_results.get("open_ports", {}) for p in ["3306", "5432", "1433", "1521", "27017", "6379"]):
                db_results = analyze_database_security(scan_results)
                scan_results["database_security"] = db_results
            
            # Add web server configuration analysis
            if any(p in scan_results.get("open_ports", {}) for p in ["80", "443", "8080", "8443"]):
                web_results = analyze_web_security(scan_results)
                scan_results["web_security"] = web_results
                
            # Add financial security score
            scan_results["financial_impact"] = calculate_financial_impact(scan_results)
            
            # Save processed results
            json_output = os.path.join(self.output_dir, f"{scan_id}_vulns.json")
            with open(json_output, 'w') as f:
                json.dump(scan_results, f, indent=4)
            
            self.logger.info(f"Vulnerability scan completed for {target}. Found {len(scan_results.get('vulnerabilities', []))} vulnerabilities")
            
            return scan_results
        except subprocess.CalledProcessError as e:
            self.logger.error(f"Error running nmap: {e}")
            self.logger.error(f"Stderr: {e.stderr}")
            return {
                "error": f"Failed to run nmap: {str(e)}",
                "target": target,
                "scan_time": datetime.now().isoformat()
            }
        except Exception as e:
            self.logger.error(f"Error in vulnerability scan: {e}")
            return {
                "error": f"Error in vulnerability scan: {str(e)}",
                "target": target,
                "scan_time": datetime.now().isoformat()
            }
    
    def _build_nmap_args(self, target: str, ports: str, intensity: str, output_file: str) -> List[str]:
        """
        Build nmap command arguments based on scan intensity
        
        Args:
            target: Target to scan
            ports: Ports to scan
            intensity: Scan intensity
            output_file: XML output file
            
        Returns:
            List of nmap command arguments
        """
        # Base command with vulnerability scripts
        base_args = [
            "nmap",
            "-oX", output_file,  # XML output
            "-p", ports          # Port specification
        ]
        
        # Common database ports to ensure they're included
        db_ports = ["3306", "5432", "1433", "1521", "27017", "6379", "9042"]
        web_ports = ["80", "443", "8080", "8443", "8000", "8008", "8888"]
        
        # Financial sector specific ports
        financial_ports = ["8443", "9443", "8843", "3000", "5000"]
        
        # Add specialized scripts for database security
        db_scripts = [
            "mysql-empty-password",
            "mysql-databases",
            "mysql-variables",
            "mysql-audit",
            "mysql-vuln-*",
            "ms-sql-info",
            "ms-sql-empty-password",
            "ms-sql-config",
            "ms-sql-ntlm-info",
            "mongodb-databases",
            "mongodb-info",
            "redis-info",
            "pgsql-databases"
        ]
        
        # Web server security scripts
        web_scripts = [
            "http-methods",
            "http-headers",
            "http-enum",
            "http-cors",
            "http-csrf",
            "http-dombased-xss",
            "http-phpself-xss",
            "http-sql-injection",
            "http-stored-xss",
            "http-cookie-flags",
            "http-shellshock",
            "ssl-*"
        ]
        
        # Financial app specific scripts
        financial_scripts = [
            "http-form-fuzzer",
            "http-passwd",
            "http-robots.txt",
            "http-vuln-*"
        ]
        
        # Add arguments based on intensity
        if intensity == "stealthy":
            # Stealthy scan - slower but less detectable
            base_args.extend([
                "-T2",           # Slower timing template
                "-f",            # Fragment packets
                "--script-args=safe=1",  # Only safe scripts
                "--script", "vuln,auth,default,discovery,version,exploit"
            ])
        elif intensity == "aggressive":
            # Aggressive scan - more comprehensive but noisy
            script_selection = [
                "vuln", "exploit", "auth", "brute", "default", "discovery", "version", 
                "malware", "intrusive", "fuzzer"
            ]
            
            # Add specialized scripts
            script_selection.extend(db_scripts)
            script_selection.extend(web_scripts)
            script_selection.extend(financial_scripts)
            
            base_args.extend([
                "-T4",           # Fast timing template
                "-A",            # Enable OS detection, version detection, script scanning, and traceroute
                "-v",            # Verbose
                "--script", ",".join(script_selection)
            ])
        else:
            # Normal scan - balanced approach
            script_selection = [
                "vuln", "auth", "default", "discovery", "version", 
                "http-headers", "http-methods", "ssl-cert",
                "mysql-empty-password", "ms-sql-info", "mongodb-info", "redis-info"
            ]
            
            base_args.extend([
                "-T3",           # Normal timing template
                "-sV",           # Version detection
                "-sC",           # Default scripts
                "--script", ",".join(script_selection)
            ])
        
        # Add the target
        base_args.append(target)
        
        return base_args
    
    def _parse_nmap_output(self, xml_file: str) -> Dict[str, Any]:
        """
        Parse nmap XML output file to extract vulnerabilities and other findings
        
        Args:
            xml_file: Path to nmap XML output file
            
        Returns:
            Dictionary with parsed results
        """
        if not os.path.exists(xml_file):
            self.logger.error(f"XML output file not found: {xml_file}")
            return {"error": "Scan output file not found"}
        
        try:
            tree = ET.parse(xml_file)
            root = tree.getroot()
            
            # Initialize results
            results = {
                "hostname": "",
                "ip": "",
                "services": [],
                "technologies": [],
                "vulnerabilities": [],
                "open_ports": {}
            }
            
            # Extract hostname and IP
            for host in root.findall('.//host'):
                # Get IP address
                for addr in host.findall('.//address'):
                    if addr.get('addrtype') == 'ipv4':
                        results["ip"] = addr.get('addr')
                
                # Get hostname
                for hostname in host.findall('.//hostname'):
                    results["hostname"] = hostname.get('name')
                
                # Get port information and services
                for port in host.findall('.//port'):
                    port_id = port.get('portid')
                    
                    # Only process open ports
                    state = port.find('state')
                    if state is not None and state.get('state') == 'open':
                        service_info = {}
                        
                        # Get service details
                        service = port.find('service')
                        if service is not None:
                            service_name = service.get('name', '')
                            product = service.get('product', '')
                            version = service.get('version', '')
                            extra_info = service.get('extrainfo', '')
                            
                            service_info = {
                                "name": service_name,
                                "product": product,
                                "version": version,
                                "extra_info": extra_info
                            }
                            
                            # Add to technologies if we have product and version
                            if product and version:
                                technology = {
                                    "name": product.lower(),
                                    "version": version,
                                    "service": service_name,
                                    "port": port_id
                                }
                                
                                if technology not in results["technologies"]:
                                    results["technologies"].append(technology)
                        
                        # Store port information
                        results["open_ports"][port_id] = service_info
                        
                        # Extract script output (vulnerabilities)
                        for script in port.findall('.//script'):
                            script_id = script.get('id', '')
                            output = script.get('output', '')
                            
                            # Process vulnerability scripts
                            if 'vuln' in script_id or any(x in script_id for x in ['ssl-', 'http-', 'ftp-', 'smb-']):
                                vuln_info = self._parse_script_output(script_id, output, port_id)
                                
                                if vuln_info:
                                    # Add service context
                                    vuln_info["service"] = service_info.get("name", "")
                                    vuln_info["port"] = port_id
                                    results["vulnerabilities"].append(vuln_info)
                                    
                                    # Add additional scripts
                                    # For SSL certificate issues
                                    if script_id == 'ssl-cert':
                                        ssl_info = self._extract_ssl_info(output)
                                        if ssl_info:
                                            results["ssl_details"] = ssl_info
                                    
                # Process host scripts (OS detection, etc.)
                for hostscript in host.findall('.//hostscript'):
                    for script in hostscript.findall('.//script'):
                        script_id = script.get('id', '')
                        output = script.get('output', '')
                        
                        # Process host-level vulnerability scripts
                        if 'vuln' in script_id:
                            vuln_info = self._parse_script_output(script_id, output, "host")
                            if vuln_info:
                                results["vulnerabilities"].append(vuln_info)
            
            # Sort vulnerabilities by severity
            if results["vulnerabilities"]:
                results["vulnerabilities"] = sorted(
                    results["vulnerabilities"], 
                    key=lambda x: self._severity_to_number(x.get("severity", "low")),
                    reverse=True
                )
            
            return results
            
        except Exception as e:
            self.logger.error(f"Error parsing nmap output: {e}")
            return {"error": f"Failed to parse scan results: {str(e)}"}
    
    def _parse_script_output(self, script_id: str, output: str, port: str) -> Optional[Dict[str, Any]]:
        """
        Parse nmap script output to extract vulnerability information
        
        Args:
            script_id: Nmap script identifier
            output: Script output text
            port: Port number the script was run against
            
        Returns:
            Dictionary with vulnerability information or None
        """
        # Skip empty output
        if not output or output.strip() == "":
            return None
        
        # Initialize vulnerability info
        vuln_info = {
            "id": "",
            "name": "",
            "description": "",
            "severity": "unknown",
            "type": "unknown",
            "script_id": script_id,
            "port": port,
            "references": []
        }
        
        # Extract CVE IDs
        cve_matches = re.findall(r'CVE-\d{4}-\d{4,}', output)
        if cve_matches:
            vuln_info["id"] = cve_matches[0]
            vuln_info["references"] = cve_matches
        
        # Extract severity information
        if re.search(r'(CRITICAL|critical)', output):
            vuln_info["severity"] = "critical"
        elif re.search(r'(HIGH|high)', output):
            vuln_info["severity"] = "high"
        elif re.search(r'(MEDIUM|medium|MODERATE|moderate)', output):
            vuln_info["severity"] = "medium"
        elif re.search(r'(LOW|low)', output):
            vuln_info["severity"] = "low"
        
        # Parse based on script_id
        if script_id.startswith('ssl-'):
            vuln_info["type"] = "ssl"
            if "cert" in script_id:
                vuln_info["name"] = "SSL Certificate Issue"
            elif "ccs" in script_id:
                vuln_info["name"] = "SSL CCS Injection"
            elif "heartbleed" in script_id:
                vuln_info["name"] = "Heartbleed Vulnerability"
                vuln_info["severity"] = "critical"
            elif "poodle" in script_id:
                vuln_info["name"] = "POODLE Vulnerability"
                vuln_info["severity"] = "high"
        elif script_id.startswith('http-'):
            vuln_info["type"] = "web"
            if "csrf" in script_id:
                vuln_info["name"] = "CSRF Vulnerability"
            elif "xss" in script_id:
                vuln_info["name"] = "XSS Vulnerability"
                vuln_info["severity"] = "high"
            elif "sql" in script_id:
                vuln_info["name"] = "SQL Injection Vulnerability"
                vuln_info["severity"] = "critical"
        elif script_id.startswith('smb-'):
            vuln_info["type"] = "smb"
            if "ms17-010" in script_id:
                vuln_info["name"] = "MS17-010 (EternalBlue)"
                vuln_info["severity"] = "critical"
        elif script_id.startswith('ftp-'):
            vuln_info["type"] = "ftp"
        
        # Set description from output
        vuln_info["description"] = output.strip()
        
        # Set a default name if not already set
        if not vuln_info["name"]:
            vuln_info["name"] = f"Vulnerability detected by {script_id}"
        
        return vuln_info
    
    def _extract_ssl_info(self, output: str) -> Dict[str, Any]:
        """
        Extract SSL certificate information from script output
        
        Args:
            output: SSL script output
            
        Returns:
            Dictionary with SSL certificate details
        """
        ssl_info = {
            "issuer": "",
            "subject": "",
            "valid_from": "",
            "valid_to": "",
            "self_signed": False
        }
        
        # Extract issuer
        issuer_match = re.search(r'Issuer: (.*?)(?:\n|$)', output)
        if issuer_match:
            ssl_info["issuer"] = issuer_match.group(1).strip()
        
        # Extract subject
        subject_match = re.search(r'Subject: (.*?)(?:\n|$)', output)
        if subject_match:
            ssl_info["subject"] = subject_match.group(1).strip()
        
        # Extract validity dates
        valid_from_match = re.search(r'Not valid before: (.*?)(?:\n|$)', output)
        if valid_from_match:
            ssl_info["valid_from"] = valid_from_match.group(1).strip()
        
        valid_to_match = re.search(r'Not valid after: (.*?)(?:\n|$)', output)
        if valid_to_match:
            ssl_info["valid_to"] = valid_to_match.group(1).strip()
        
        # Check if self-signed
        if ssl_info["issuer"] == ssl_info["subject"]:
            ssl_info["self_signed"] = True
        
        return ssl_info
    
    def _severity_to_number(self, severity: str) -> int:
        """
        Convert severity string to numeric value for sorting
        
        Args:
            severity: Severity string
            
        Returns:
            Numeric severity value
        """
        severity_map = {
            "critical": 4,
            "high": 3,
            "medium": 2,
            "low": 1,
            "unknown": 0
        }
        return severity_map.get(severity.lower(), 0)
    
    def get_vulnerabilities_by_severity(self, scan_results: Dict[str, Any]) -> Dict[str, List[Dict[str, Any]]]:
        """
        Organize vulnerabilities by severity
        
        Args:
            scan_results: Results from scan_target
            
        Returns:
            Dictionary with vulnerabilities organized by severity
        """
        vulnerabilities = scan_results.get("vulnerabilities", [])
        
        # Initialize result
        result = {
            "critical": [],
            "high": [],
            "medium": [],
            "low": [],
            "unknown": []
        }
        
        # Categorize vulnerabilities
        for vuln in vulnerabilities:
            severity = vuln.get("severity", "unknown").lower()
            if severity in result:
                result[severity].append(vuln)
            else:
                result["unknown"].append(vuln)
        
        return result
    
    def get_vulnerabilities_by_type(self, scan_results: Dict[str, Any]) -> Dict[str, List[Dict[str, Any]]]:
        """
        Organize vulnerabilities by type
        
        Args:
            scan_results: Results from scan_target
            
        Returns:
            Dictionary with vulnerabilities organized by type
        """
        vulnerabilities = scan_results.get("vulnerabilities", [])
        
        # Initialize result
        result = {}
        
        # Categorize vulnerabilities
        for vuln in vulnerabilities:
            vuln_type = vuln.get("type", "unknown").lower()
            
            if vuln_type not in result:
                result[vuln_type] = []
                
            result[vuln_type].append(vuln)
        
        return result
    
    def generate_report(self, scan_results: Dict[str, Any], format: str = "text") -> str:
        """
        Generate a readable vulnerability report
        
        Args:
            scan_results: Results from scan_target
            format: Output format (text or json)
            
        Returns:
            Formatted report
        """
        if format == "json":
            return json.dumps(scan_results, indent=4)
        
        # Generate text report
        target = scan_results.get("target", "Unknown")
        hostname = scan_results.get("hostname", "")
        ip = scan_results.get("ip", "")
        scan_time = scan_results.get("scan_time", "")
        vulnerabilities = scan_results.get("vulnerabilities", [])
        
        # Organize vulnerabilities by severity
        vulns_by_severity = self.get_vulnerabilities_by_severity(scan_results)
        
        # Build the report
        report = [
            f"FinGuardAI Vulnerability Scan Report",
            f"Target: {target}",
            f"Hostname: {hostname}" if hostname else "",
            f"IP Address: {ip}" if ip else "",
            f"Scan Time: {scan_time}",
            f"\n--- VULNERABILITY SUMMARY ---",
            f"Critical: {len(vulns_by_severity['critical'])}",
            f"High: {len(vulns_by_severity['high'])}",
            f"Medium: {len(vulns_by_severity['medium'])}",
            f"Low: {len(vulns_by_severity['low'])}",
            f"Unknown: {len(vulns_by_severity['unknown'])}"
        ]
        
        # Add detected technologies
        technologies = scan_results.get("technologies", [])
        if technologies:
            report.append("\n--- DETECTED TECHNOLOGIES ---")
            for tech in technologies:
                report.append(f"{tech.get('name', 'Unknown')} {tech.get('version', '')}")
        
        # Add open ports
        open_ports = scan_results.get("open_ports", {})
        if open_ports:
            report.append("\n--- OPEN PORTS ---")
            for port, service in open_ports.items():
                service_name = service.get("name", "")
                product = service.get("product", "")
                version = service.get("version", "")
                service_str = f"{service_name}"
                if product:
                    service_str += f" ({product}"
                    if version:
                        service_str += f" {version}"
                    service_str += ")"
                report.append(f"Port {port}: {service_str}")
        
        # Add vulnerabilities by severity
        if vulnerabilities:
            for severity in ["critical", "high", "medium", "low", "unknown"]:
                vulns = vulns_by_severity[severity]
                if vulns:
                    report.append(f"\n--- {severity.upper()} VULNERABILITIES ---")
                    for i, vuln in enumerate(vulns, 1):
                        vuln_id = vuln.get("id", "")
                        name = vuln.get("name", "Unknown Vulnerability")
                        port = vuln.get("port", "")
                        service = vuln.get("service", "")
                        description = vuln.get("description", "")
                        
                        # Truncate long descriptions
                        if len(description) > 200:
                            description = description[:197] + "..."
                        
                        report.append(f"{i}. {name} {f'({vuln_id})' if vuln_id else ''}")
                        if port and service:
                            report.append(f"   Port {port} ({service})")
                        report.append(f"   {description.replace(chr(10), ' ')}")
                        report.append("")
        
        # SSL-specific details
        if "ssl_details" in scan_results:
            ssl = scan_results["ssl_details"]
            report.append("\n--- SSL CERTIFICATE DETAILS ---")
            report.append(f"Issuer: {ssl.get('issuer', '')}")
            report.append(f"Subject: {ssl.get('subject', '')}")
            report.append(f"Valid From: {ssl.get('valid_from', '')}")
            report.append(f"Valid To: {ssl.get('valid_to', '')}")
            report.append(f"Self-Signed: {'Yes' if ssl.get('self_signed', False) else 'No'}")
        
        return "\n".join([line for line in report if line])


# For command-line usage
if __name__ == "__main__":
    import argparse
    
    parser = argparse.ArgumentParser(description="FinGuardAI Vulnerability Scanner")
    parser.add_argument("target", help="Target to scan (domain, IP, or URL)")
    parser.add_argument("--ports", default="1-1000,3306,8080-8090", help="Ports to scan")
    parser.add_argument("--intensity", choices=["stealthy", "normal", "aggressive"], default="normal", help="Scan intensity")
    parser.add_argument("--output", "-o", help="Output report file")
    parser.add_argument("--format", "-f", choices=["text", "json"], default="text", help="Output format")
    
    args = parser.parse_args()
    
    # Configure logging
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    
    # Run the scan
    scanner = VulnerabilityScanner()
    results = scanner.scan_target(args.target, args.ports, args.intensity)
    
    # Generate and output report
    report = scanner.generate_report(results, args.format)
    
    if args.output:
        with open(args.output, 'w') as f:
            f.write(report)
        print(f"Report saved to {args.output}")
    else:
        print(report)
