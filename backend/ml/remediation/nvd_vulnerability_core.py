"""
FinGuardAI - NVD Vulnerability Core

Core functionality for extracting and analyzing vulnerability data from NVD.
"""

import os
import json
import logging
import datetime
from typing import Dict, List, Any, Optional, Tuple

from .nvd_client import NVDClient, generate_cpe_name

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("finguardai.vuln_core")

# NVD API key
NVD_API_KEY = "7a30b327-dc77-4262-acc6-399171f7dacb"

# Real EOL dates for common technologies
EOL_DATES = {
    "apache": {
        "2.4.51": "2023-06-01",  # Already EOL
        "2.4.52": "2023-09-01",  # Already EOL
        "2.4.53": "2024-06-01",  # Already EOL
        "2.4.54": "2024-09-01", 
        "2.4.56": "2025-06-01",
        "2.4.57": "2025-11-01"
    },
    "nginx": {
        "1.20.1": "2023-01-01",  # Already EOL
        "1.22.1": "2024-04-01",  # Already EOL
        "1.24.0": "2025-04-01"
    },
    "openssh": {
        "8.2p1": "2023-04-01",  # Already EOL
        "8.8p1": "2025-12-01"
    },
    "mysql": {
        "5.7.36": "2022-12-01",  # Already EOL
        "8.0.31": "2024-04-01",  # Already EOL
        "8.0.33": "2025-10-01"
    },
    "php": {
        "7.4.21": "2022-11-28",  # Already EOL
        "8.0.10": "2023-11-26",  # Already EOL
        "8.1.16": "2024-11-25",
        "8.2.5": "2025-12-08"
    }
}

# Upgrade paths for technologies (best secure versions to upgrade to)
UPGRADE_PATHS = {
    "apache": {
        "2.4.51": "2.4.57",  # Upgrade to latest stable
    },
    "nginx": {
        "1.20.1": "1.24.0",  # Upgrade to latest stable
    },
    "openssh": {
        "8.2p1": "8.8p1",    # Upgrade to latest stable
    },
    "mysql": {
        "5.7.36": "8.0.33",  # Upgrade to latest stable
    },
    "php": {
        "7.4.21": "8.2.5",   # Upgrade to latest stable
    }
}

def get_days_until_eol(tech: str, version: str) -> int:
    """
    Calculate days until end-of-life for a technology version
    
    Args:
        tech: Technology name
        version: Version string
        
    Returns:
        Days until EOL, negative if already EOL
    """
    tech_eol = EOL_DATES.get(tech.lower(), {})
    eol_date_str = tech_eol.get(version)
    
    if not eol_date_str:
        logger.warning(f"No EOL date found for {tech} {version}")
        return 999  # Far in the future
    
    eol_date = datetime.datetime.strptime(eol_date_str, "%Y-%m-%d")
    days_until_eol = (eol_date - datetime.datetime.now()).days
    
    return days_until_eol

def get_recommended_version(tech: str, version: str) -> str:
    """
    Get recommended upgrade version for a technology
    
    Args:
        tech: Technology name
        version: Current version
        
    Returns:
        Recommended version to upgrade to
    """
    tech_upgrades = UPGRADE_PATHS.get(tech.lower(), {})
    return tech_upgrades.get(version, version)

def classify_vulnerability_type(description: str) -> List[str]:
    """
    Classify vulnerability type based on description
    
    Args:
        description: Vulnerability description
        
    Returns:
        List of vulnerability types
    """
    description = description.lower()
    
    # Common vulnerability types and their keywords
    vuln_types = {
        "SQL Injection": ["sql injection", "sqli", "sql", "injection"],
        "Cross-Site Scripting (XSS)": ["xss", "cross-site scripting", "cross site scripting"],
        "Cross-Site Request Forgery (CSRF)": ["csrf", "cross-site request forgery"],
        "Remote Code Execution": ["rce", "remote code execution", "remote execution", "code execution"],
        "Command Injection": ["command injection", "cmd injection", "command execution"],
        "Path Traversal": ["path traversal", "directory traversal", "../", "path injection"],
        "Information Disclosure": ["information disclosure", "information leakage", "data leakage", "sensitive data"],
        "Authentication Bypass": ["auth bypass", "authentication bypass", "bypass authentication"],
        "Privilege Escalation": ["privilege escalation", "privilege elevation", "elevation of privilege"],
        "Buffer Overflow": ["buffer overflow", "stack overflow", "heap overflow", "buffer overrun"],
        "Denial of Service": ["denial of service", "dos", "crash", "resource exhaustion"],
        "Memory Corruption": ["memory corruption", "use-after-free", "use after free", "memory safety"],
        "HTTP Request Smuggling": ["request smuggling", "http smuggling"],
        "Server-Side Request Forgery": ["ssrf", "server-side request forgery"],
        "XML External Entity": ["xxe", "xml external entity"],
        "Cryptographic Weakness": ["weak crypto", "cryptographic", "encryption", "cipher", "weak hash"],
        "Insecure Deserialization": ["deserialization", "deserialize", "unmarshalling"]
    }
    
    # Find matching vulnerability types
    found_types = []
    for vuln_type, keywords in vuln_types.items():
        for keyword in keywords:
            if keyword in description:
                found_types.append(vuln_type)
                break
    
    # If no specific type was found, return a generic one
    if not found_types:
        if "vulnerability" in description:
            return ["Security Vulnerability"]
        else:
            return ["Unknown Vulnerability"]
    
    # Return unique vulnerability types
    return list(set(found_types))

def extract_cve_info(vuln_data: Dict[str, Any]) -> Dict[str, Any]:
    """
    Extract relevant information from a CVE entry
    
    Args:
        vuln_data: Vulnerability data from NVD API
        
    Returns:
        Dictionary with extracted CVE information
    """
    cve_info = {}
    
    try:
        # Get CVE data
        cve = vuln_data.get("cve", {})
        
        # Extract CVE ID
        cve_info["id"] = cve.get("id", "Unknown CVE")
        
        # Extract description
        description = "No description available"
        for desc in cve.get("descriptions", []):
            if desc.get("lang") == "en":
                description = desc.get("value", "No description available")
                break
        cve_info["description"] = description
        
        # Extract vulnerability types
        cve_info["vulnerability_types"] = classify_vulnerability_type(description)
        
        # Extract CVSS metrics if available
        metrics = vuln_data.get("metrics", {})
        
        # Try CVSS v3.1
        cvss_v3 = metrics.get("cvssMetricV31", [{}])[0].get("cvssData", {}) if metrics.get("cvssMetricV31") else {}
        if cvss_v3:
            cve_info["cvss_score"] = cvss_v3.get("baseScore")
            cve_info["cvss_severity"] = cvss_v3.get("baseSeverity")
        else:
            # Try CVSS v3.0
            cvss_v3 = metrics.get("cvssMetricV30", [{}])[0].get("cvssData", {}) if metrics.get("cvssMetricV30") else {}
            if cvss_v3:
                cve_info["cvss_score"] = cvss_v3.get("baseScore")
                cve_info["cvss_severity"] = cvss_v3.get("baseSeverity")
            else:
                # Try CVSS v2.0
                cvss_v2 = metrics.get("cvssMetricV2", [{}])[0].get("cvssData", {}) if metrics.get("cvssMetricV2") else {}
                if cvss_v2:
                    cve_info["cvss_score"] = cvss_v2.get("baseScore")
                    cve_info["cvss_severity"] = "N/A"
                else:
                    cve_info["cvss_score"] = 0.0
                    cve_info["cvss_severity"] = "Unknown"
        
        # Extract publication date
        cve_info["published_date"] = cve.get("published")
        
        # Extract last modified date
        cve_info["last_modified_date"] = cve.get("lastModified")
    
    except Exception as e:
        logger.error(f"Error extracting CVE info: {e}")
    
    return cve_info

def fetch_vulnerabilities_for_technology(tech: str, version: str) -> List[Dict[str, Any]]:
    """
    Fetch vulnerabilities for a specific technology and version
    
    Args:
        tech: Technology name (e.g., apache, nginx)
        version: Version string
        
    Returns:
        List of vulnerability dictionaries
    """
    # Create NVD client
    client = NVDClient(api_key=NVD_API_KEY)
    
    # Generate CPE name
    cpe_name = generate_cpe_name(tech, version)
    
    # Fetch vulnerabilities
    vulnerabilities = client.get_vulnerabilities_by_cpe(cpe_name=cpe_name)
    
    # Process and extract information from vulnerabilities
    processed_vulns = []
    for vuln in vulnerabilities:
        cve_info = extract_cve_info(vuln)
        if cve_info:
            processed_vulns.append(cve_info)
    
    # Sort by CVSS score
    processed_vulns.sort(key=lambda x: float(x.get("cvss_score", 0) or 0), reverse=True)
    
    return processed_vulns

def determine_prediction_timeframe(days_until_eol: int) -> str:
    """
    Determine prediction timeframe based on days until EOL
    
    Args:
        days_until_eol: Days until EOL
        
    Returns:
        Timeframe string (1_day, 1_week, 10_days or None)
    """
    if days_until_eol <= 0:
        return "1_day"  # Immediate action required
    elif days_until_eol <= 7:
        return "1_week"
    elif days_until_eol <= 10:
        return "10_days"
    else:
        return None  # Not in our timeframes
